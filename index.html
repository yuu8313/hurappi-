<!DOCTYPE html>
<html lang="ja">
<head>
　  <link rel="icon" href="https://raw.githubusercontent.com/yuu8313/hurappi-/refs/heads/main/images/a/fabikon.png" type="image/png">
    <meta charset="UTF-8">
    <audio id="bgm" src="audio/bgm.mp3" loop></audio>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ふらッピー ゲーム </title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #70c5ce;
        }

        canvas {
            display: block;
            background: url('images/background.png') no-repeat center center;
            background-size: cover;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        // キャンバスの設定
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // ウィンドウサイズに応じたキャンバスのサイズ調整
        const resizeCanvas = () => {
            canvas.width = window.innerWidth > 480 ? 320 : window.innerWidth;  // 最大幅を320pxに制限
            canvas.height = window.innerHeight > 720 ? 480 : window.innerHeight;  // 最大高さを480pxに制限
        };
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        const bgm = document.getElementById("bgm");// BGMをロード

        // 画像のロード
        const images = {};
        let imagesLoaded = 0;
        const loadImages = () => {
            const imageFiles = ['background', 'bird1', 'bird2', 'bird3', 'down_bar', 'up_bar'];
            imageFiles.forEach(img => {
                images[img] = new Image();
                images[img].src = `images/${img}.png`;
                images[img].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === imageFiles.length) {
                        startGame();  // 画像がすべてロードされたらゲーム開始
                    }
                };
                images[img].onerror = () => {
                    console.error(`Failed to load image: ${img}`);
                };
            });
        };

        loadImages();

        // ゲームの変数
        let fura = {  // ふら。の設定
            x: 50,  // ふら。のX座標
            y: 150,  // ふら。のY座標
            width: 42,  // ふら。の幅 (42ピクセル)
            height: 38,  // ふら。の高さ (41ピクセル)
            gravity: 0.25,  // 重力の強さ
            velocity: 0,  // ふら。の速度
            lift: -5,  // ジャンプ時の上昇力
            frame: 0  // アニメーションのためのフレームカウンタ
        };

        let pipes = [];  // 障害物のリスト
        let pipeWidth = 50;  // 障害物の幅
        let pipeGap = 120;  // 上下の障害物の間隔
        let pipeSpeed = 2;  // 障害物の移動速度
        let minPipeDistance = 200;  // 障害物同士の最小距離

        let score = 0;  // スコアの変数
        let isGameOver = false;  // ゲームオーバーかどうかのフラグ
        let gameInterval;  // 障害物の生成間隔を管理する変数
        let jumpAllowed = true;  // ジャンプが許可されているかどうか

        // 障害物生成
        const createPipes = () => {
            // 前回の障害物がまだ十分に遠くない場合、新しい障害物を生成しない
            if (pipes.length > 0 && pipes[pipes.length - 1].x > canvas.width - minPipeDistance) {
                return;
            }

            let pipeHeight = Math.floor(Math.random() * (canvas.height / 2)) + 50;
            pipes.push({
                x: canvas.width,  // 障害物のX座標（画面外からスタート）
                y: pipeHeight,  // 障害物の高さ（ランダム）
                width: pipeWidth,  // 障害物の幅
                height: pipeHeight  // 障害物の高さ
            });
        };

        // 初期化
        const resetGame = () => {
            fura.y = 150;  // ふら。の初期位置
            fura.velocity = 0;  // ふら。の速度をリセット
            pipes = [];  // 障害物リストをクリア
            score = 0;  // スコアをリセット
            isGameOver = false;  // ゲームオーバー状態をリセット
            jumpAllowed = true;  // ジャンプを許可
            createPipes();  // 最初の障害物を生成
            bgm.currentTime = 0;  // BGMを最初から再生
            bgm.play();  // BGMを再生
        };

        // 背景の描画
        const drawBackground = () => {
            ctx.drawImage(images['background'], 0, 0, canvas.width, canvas.height);  // 背景画像をキャンバスに描画
        };

        // ふら。の描画
        const drawFura = () => {
            let birdImage = images[`bird${Math.floor(fura.frame / 10) % 3 + 1}`];  // アニメーション用に3フレームを切り替え
            ctx.drawImage(birdImage, fura.x, fura.y, fura.width, fura.height);  // ふら。を描画
        };

        // 障害物の描画
        const drawPipes = () => {
            pipes.forEach(pipe => {
                // 上向き障害物
                ctx.drawImage(images['up_bar'], pipe.x, pipe.y - pipe.height - pipeGap, pipe.width, pipe.height);
                // 下向き障害物
                ctx.drawImage(images['down_bar'], pipe.x, pipe.y, pipe.width, canvas.height - pipe.y);
            });
        };

        // スコア表示
        const drawScore = () => {
            ctx.font = "20px Arial";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "left";
            ctx.fillText("Score: " + score, 10, 30);  // 左上にスコアを表示
        };

        // ゲームオーバー画面
        const gameOver = () => {
            isGameOver = true;  // ゲームオーバーのフラグをセット
            clearInterval(gameInterval);  // 障害物生成のインターバルをクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // キャンバスをクリア
            drawBackground();  // 背景を描画してからメッセージ表示
            ctx.font = "30px Arial";
            ctx.fillStyle = "#ff0000";  // 赤色のテキスト
            ctx.textAlign = "center";
            ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 10);  // ゲームオーバーのメッセージ
            ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2 + 30);  // スコアの表示
        };

        // 障害物に当たった際の処理
        const onCollision = () => {
            // ふら。を「dead.png」に変更して表示
            ctx.drawImage(images['dead'], fura.x, fura.y, fura.width, fura.height);
            gameOver();  // ゲームオーバー処理
        };

        // ゲームの更新処理
        const updateGame = () => {
            if (isGameOver) return;  // ゲームオーバーの場合、更新しない

            // ふら。の物理挙動（重力）
            fura.velocity += fura.gravity;  // 重力によって速度が増加
            fura.y += fura.velocity;  // ふら。のY座標を更新

            // ふら。が画面外に出ないように制限
            if (fura.y + fura.height >= canvas.height) {
                fura.y = canvas.height - fura.height;  // 地面にぶつかると停止
                onCollision();  // ゲームオーバー
                return;
            }
            if (fura.y <= 0) {
                fura.y = 0;  // 画面の上に出ないように制限
                fura.velocity = 0;  // 速度をゼロにして止める
            }

            // 障害物の移動と当たり判定
            pipes.forEach(pipe => {
                pipe.x -= pipeSpeed;  // 障害物を左に移動

                // ふら。が障害物にぶつかったかどうかの判定
                if (
                    fura.x < pipe.x + pipe.width &&  // ふら。が障害物の範囲内に入っているか
                    fura.x + fura.width > pipe.x &&
                    (fura.y < pipe.y - pipeGap || fura.y + fura.height > pipe.y)  // ふら。が上下の障害物に触れているか
                ) {
                    onCollision();  // 障害物に当たったらゲームオーバーイベント
                    return;  // 障害物に当たった後は処理を中断
                }
            });

            // 画面外の障害物を削除し、スコアを加算
            if (pipes.length && pipes[0].x + pipeWidth < fura.x) {
                pipes.shift();  // 古い障害物を削除
                score++;  // スコアを1追加
                createPipes();  // 新しい障害物を生成
            }

            // 描画クリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 背景を描画
            drawBackground();

            // 障害物を描画
            drawPipes();

            // ふら。を描画
            drawFura();

            // スコアを描画
            drawScore();
        };

        // ゲームのメインループ
        const gameLoop = () => {
            updateGame();  // ゲーム状態を更新
            requestAnimationFrame(gameLoop);  // 次のフレームで再実行
        };

        // スペースキーを押すとふら。がジャンプ
        document.addEventListener("keydown", (e) => {
            if (e.code === "Space" && !isGameOver && jumpAllowed) {
                fura.velocity = fura.lift;  // ふら。がジャンプ
                jumpAllowed = false;  // ジャンプを一時的に無効にする
            } else if (isGameOver && e.code === "Space") {
                resetGame();  // ゲームオーバー時にスペースを押すとリセット
                gameInterval = setInterval(createPipes, 3000);  // 障害物生成を再開
            }
        });

        // スペースキーを離すと再度ジャンプ可能にする
        document.addEventListener("keyup", (e) => {
            if (e.code === "Space") {
                jumpAllowed = true;  // ジャンプを再び許可
            }
        });

        // ゲーム開始
        const startGame = () => {
            resetGame();  // ゲームの初期化
            gameInterval = setInterval(createPipes, 3000);  // 障害物生成の間隔を設定
            gameLoop();  // ゲームループを開始
        };
    </script>
</body>
</html>
